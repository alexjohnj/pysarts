import glob
import os.path

import numpy as np
from scipy.interpolate import RectBivariateSpline
from netCDF4 import Dataset

from . import util

def find_ifgs_for_dates(ifg_dir, master_date, slc_dates=None):
    """Find all the interferograms for a set of SLC dates and a given master date.

    Arguments
    ---------
    ifg_dir : str
      The directory to search for interferograms. Interferograms should be named
      as SLAVE_MASTER.nc where SLAVE and MASTER are datestamps in the format
      YYYYMMDD.
    master_date : date
      The master date.
    slc_dates : list(date), opt
      SLC dates to consider when selecting interferograms. A value of `None`
      (default) means use all the files in ifg_dir.

    Returns
    -------
    A list of files that are made up of images from `master_date` or `slc_dates`.
    """
    ifg_files = glob.glob(os.path.join(ifg_dir, '*.nc'))

    if not slc_dates:
        return ifg_files
    else:
        slc_dates.append(master_date)

    accepted_files = []
    for file in ifg_files:
        ifg_master_date, ifg_slave_date = util.extract_timestamp_from_ifg_name(file)
        if ifg_master_date in slc_dates and ifg_slave_date in slc_dates:
            accepted_files.append(file)

    return accepted_files

def open_ifg_netcdf(path):
    """Open an NetCDF interferogram and read the longitudes, latitudes and data.

    Arguments
    ---------
    path : str
      The path to a NetCDF file to read.

    Returns
    -------
    A `dict` with the keys "lons", "lats", "data", "master_date", "slave_date".
    """
    ifg = {}
    with Dataset(path) as ifg_cdf:
        ifg['lons'] = ifg_cdf.variables['x'][:]
        ifg['lats'] = ifg_cdf.variables['y'][:]
        ifg['data'] = ifg_cdf.variables['z'][:]

    # Get master and slave dates
    ifg['master_date'], ifg['slave_date'] = util.extract_timestamp_from_ifg_name(path)

    return ifg

def clip_ifg(ifg, lon_bounds, lat_bounds):
    """Clips an interferogram to a rectangular region.

    If the bounding box's corners align with the grid, they will be included
    in the clipped data. If the corners are misaligned with the grid, they
    will be rounded to the nearest grid point rounding *down* if they fall
    halfway inside of a grid cell.

    Arguments
    ---------
    ifg : dict
      An interferogram dictionary, as generated by `open_ifg_netcdf`. This
      argument will be mutated.
    lon_bounds : tuple
      2-tuple containing (lower, upper) bounds for longitude.
    lat_bounds : tuple
      2-tuple containing (lower, upper) bounds for latitude.

    Returns
    -------
    None
    """
    lon_min, lon_max = min(lon_bounds), max(lon_bounds)
    lat_min, lat_max = min(lat_bounds), max(lat_bounds)

    if (not _point_is_in_grid(ifg['lons'], ifg['lats'], lon_min, lat_min)
        or not _point_is_in_grid(ifg['lons'], ifg['lats'], lon_max, lat_max)):
        raise IndexError('Bounding box is outside of the grid.')

    lon_min_idx = np.argmin(np.abs(ifg['lons'] - lon_min))
    lon_max_idx = np.argmin(np.abs(ifg['lons'] - lon_max))

    lat_min_idx = np.argmin(np.abs(ifg['lats'] - lat_min))
    lat_max_idx = np.argmin(np.abs(ifg['lats'] - lat_max))

    ifg['data'] = ifg['data'][lat_min_idx:lat_max_idx+1, lon_min_idx:lon_max_idx+1]
    ifg['lons'] = ifg['lons'][lon_min_idx:lon_max_idx+1]
    ifg['lats'] = ifg['lats'][lat_min_idx:lat_max_idx+1]

def _resample_ifg(ifg, new_lons, new_lats):
    """Resamples an IFG onto a new set of longitudes and latitudes."""
    spline_f = RectBivariateSpline(ifg['lons'], ifg['lats'], ifg['data'].transpose())
    ifg['data'] = spline_f(new_lons, new_lats, grid=True).transpose()
    ifg['lons'] = new_lons
    ifg['lats'] = new_lats

def resample_ifg(ifg, delta_x, delta_y):
    """Resamples an IFG at a new resolution.

    Note that delta_x and delta_y are converted to degrees assuming 1Ëš =
    111.11km. This approximation work reasonably well but may fall apart near
    the poles.

    Arguments
    ---------
    ifg : dict
      An interferogram dictionary as produced by `open_ifg_netcdf`. Mutated.
    delta_x, delta_y : float
      The x and y resolutions in metres.

    Returns
    -------
    None
    """
    # Convert resolutions to degrees
    metre_to_deg = lambda x: x / 111110
    delta_x_deg = metre_to_deg(delta_x)
    delta_y_deg = metre_to_deg(delta_y)

    new_lons = np.arange(ifg['lons'][0], ifg['lons'][-1], delta_x_deg)
    new_lats = np.arange(ifg['lats'][0], ifg['lats'][-1], delta_y_deg)

    _resample_ifg(ifg, new_lons, new_lats)

def _point_is_in_grid(grid_x, grid_y, x, y):
    """Check if a point falls within a grid.

    Arguments
    ---------
    grid_x, grid_y : ndarray
      x and y axes of the grid.
    x, y : float
      x and y coordinates to test

    Returns
    -------
    `True` if (x, y) lies within the grid. Otherwise `False`.
    """
    return (np.amin(grid_x) <= x <= np.amax(grid_x)
            and
            np.amin(grid_y) <= y <= np.amax(grid_y))
